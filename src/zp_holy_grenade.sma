/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <cstrike>
#include <fun>
#include <fakemeta>
#include <engine>
#include <hamsandwich>
#include <zombieplague>

#define VERSION "1.0"

new const NADE_TYPE_HOLY = 2137;
new const NADE_DURATION_HOLY = pev_flSwimTime;
new const g_sound[] = "weapons/holy.wav";
new const g_vmodel[] = "models/v_holygrenade.mdl";
new const g_pmodel[] = "models/p_holygrenade.mdl";
new const g_wmodel[] = "models/w_holygrenade.mdl";
new const g_trailspr[] ="sprites/laserbeam.spr";
new const g_firespr[] = "sprites/fexplo.spr";
new const g_flare[] = "models/zombie_plague/v_grenade_flare.mdl";

new ma_holy[33];
new g_trail
new g_fire
new g_death
new g_score
new holyid
new cvar_holydmg
new cvar_holycost

public plugin_init() {
	register_plugin("[ZP] Holy Hand Grenade", VERSION, "bako35")
	register_event("CurWeapon", "replace_models", "be", "1=1")
	register_forward(FM_SetModel,"fw_SetModel", 1);
	RegisterHam(Ham_Think, "grenade", "fw_ThinkGren");
	RegisterHam(Ham_Spawn, "player", "fw_Spawn");
	
	cvar_holydmg = register_cvar("zp_holygrenade_dmg", "2500");
	cvar_holycost = register_cvar("zp_holygrenade_cost", "20");
	
	holyid = zp_register_extra_item("Holy Hand Grenade", get_pcvar_num(cvar_holycost), ZP_TEAM_HUMAN);
	g_death = get_user_msgid("DeathMsg");
	g_score = get_user_msgid("ScoreInfo");
}

public plugin_precache(){
	precache_model(g_vmodel);
	precache_model(g_pmodel);
	precache_model(g_wmodel);
	precache_model(g_flare);
	precache_sound(g_sound);
	g_trail = precache_model(g_trailspr);
	g_fire = precache_model(g_firespr);
	
}

public client_connect(id){
	ma_holy[id] = false;
}

public client_disconnect(id){
	ma_holy[id] = false;
}

public fw_Spawn(id){
	ma_holy[id] = false;
}

public zp_extra_item_selected(id, itemid){
	if(itemid == holyid){
	if(is_user_alive(id)){
		new was = cs_get_user_bpammo(id, CSW_SMOKEGRENADE);
		if(was >= 1){
			cs_set_user_bpammo(id, CSW_SMOKEGRENADE, was + 1);
		}
		else{
			give_item(id, "weapon_smokegrenade");
		}
		ma_holy[id] = true;
		replace_models(id);
	}
	else{
		client_print(id, print_center, "Nie zyjesz!");
	}
}
}

public replace_models(id)
{
	new weapon = read_data(2);
	
	if(ma_holy[id]){		
		if(weapon == CSW_SMOKEGRENADE)
		{
			set_pev(id, pev_viewmodel2, g_vmodel);
			set_pev(id, pev_weaponmodel2, g_pmodel);
		}
	}
}

public replace_models2(id){
	if(get_user_weapon(id) == CSW_SMOKEGRENADE)
		set_pev(id, pev_viewmodel2, g_flare);
}

public fw_SetModel(entity, const model[]){ // Set smokegrenade pipes effects and type
	static Float:dmgtime, owner;
	pev(entity, pev_dmgtime, dmgtime);
	owner = pev(entity, pev_owner);
	
	if(!pev_valid(entity) || dmgtime == 0.0)
		return FMRES_IGNORED;
	
	if (model[9] == 's' && model[10] == 'm' && ma_holy[owner])
	{
		ma_holy[owner] = false;
		entity_set_model(entity, g_wmodel);
		replace_models2(owner);
		
		set_rendering(entity, kRenderFxGlowShell, 255, 215, 0, kRenderNormal, 16);
		
		message_begin(MSG_BROADCAST, SVC_TEMPENTITY)
		write_byte(TE_BEAMFOLLOW) // TE id
		write_short(entity) // entity
		write_short(g_trail) // sprite
		write_byte(10) // life
		write_byte(10) // width
		write_byte(255) // r
		write_byte(215) // g
		write_byte(0) // b
		write_byte(255) // brightness
		message_end()
		
		set_pev(entity, pev_flTimeStepSound, NADE_TYPE_HOLY);
		
		return FMRES_SUPERCEDE;
	}
	
	return FMRES_IGNORED;
}

public fw_ThinkGren(entity){ // Grenade think event
if (!pev_valid(entity)){
		return HAM_IGNORED;
	}
	
static Float:dmgtime, Float: current_time, attacker;
pev(entity, pev_dmgtime, dmgtime);
current_time = get_gametime();
attacker = pev(entity, pev_owner);
	
if(dmgtime > current_time)
	return HAM_IGNORED;
	
if(pev(entity, pev_flTimeStepSound) == NADE_TYPE_HOLY)
	{
		static duration;
		duration = pev(entity, NADE_DURATION_HOLY);

	if(duration > 0)
		{
			new Float:originF[3]
			pev(entity, pev_origin, originF);
			
			if(duration == 1)
			{
				remove_task(entity);
				effect(originF);
				kill(originF, attacker);
				engfunc(EngFunc_RemoveEntity, entity);
				return HAM_SUPERCEDE;
				
			}
			set_pev(entity, NADE_DURATION_HOLY, --duration);
			set_pev(entity, pev_dmgtime, current_time + 3.0);
		}
		else if((pev(entity, pev_flags) & FL_ONGROUND) && get_speed(entity) < 10)
		{
			set_task(1.0, "holysound", entity, _, _, "a", 1);
			set_pev(entity, NADE_DURATION_HOLY, 1+2/2);
			set_pev(entity, pev_dmgtime, current_time + 0.1);
		}
		else
			set_pev(entity, pev_dmgtime, current_time + 0.5);
	}
	return HAM_IGNORED;
}

public effect(const Float:originF[3]){ // Explosion effect
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, originF, 0)
	write_byte(TE_EXPLOSION)
	engfunc(EngFunc_WriteCoord, originF[0])
	engfunc(EngFunc_WriteCoord, originF[1])
	engfunc(EngFunc_WriteCoord, originF[2])
	write_short(g_fire) //sprite index
	write_byte(50) // scale in 0.1's
	write_byte(30) // framerate
	write_byte(0) // flags
	message_end()
	
	// Smallest ring
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, originF, 0)
	write_byte(TE_BEAMCYLINDER) // TE id
	engfunc(EngFunc_WriteCoord, originF[0]) // x
	engfunc(EngFunc_WriteCoord, originF[1]) // y
	engfunc(EngFunc_WriteCoord, originF[2]) // z
	engfunc(EngFunc_WriteCoord, originF[0]) // x axis
	engfunc(EngFunc_WriteCoord, originF[1]) // y axis
	engfunc(EngFunc_WriteCoord, originF[2]+385.0) // z axis
	write_short(g_trail) // sprite
	write_byte(0) // startframe
	write_byte(0) // framerate
	write_byte(4) // life
	write_byte(60) // width
	write_byte(0) // noise
	write_byte(255) // red
	write_byte(215) // green
	write_byte(0) // blue
	write_byte(200) // brightness
	write_byte(0) // speed
	message_end()
	
	// Medium ring
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, originF, 0)
	write_byte(TE_BEAMCYLINDER) // TE id
	engfunc(EngFunc_WriteCoord, originF[0]) // x
	engfunc(EngFunc_WriteCoord, originF[1]) // y
	engfunc(EngFunc_WriteCoord, originF[2]) // z
	engfunc(EngFunc_WriteCoord, originF[0]) // x axis
	engfunc(EngFunc_WriteCoord, originF[1]) // y axis
	engfunc(EngFunc_WriteCoord, originF[2]+470.0) // z axis
	write_short(g_trail) // sprite
	write_byte(0) // startframe
	write_byte(0) // framerate
	write_byte(4) // life
	write_byte(60) // width
	write_byte(0) // noise
	write_byte(255) // red
	write_byte(215) // green
	write_byte(0) // blue
	write_byte(200) // brightness
	write_byte(0) // speed
	message_end()
	
	// Largest ring
	engfunc(EngFunc_MessageBegin, MSG_PVS, SVC_TEMPENTITY, originF, 0)
	write_byte(TE_BEAMCYLINDER) // TE id
	engfunc(EngFunc_WriteCoord, originF[0]) // x
	engfunc(EngFunc_WriteCoord, originF[1]) // y
	engfunc(EngFunc_WriteCoord, originF[2]) // z
	engfunc(EngFunc_WriteCoord, originF[0]) // x axis
	engfunc(EngFunc_WriteCoord, originF[1]) // y axis
	engfunc(EngFunc_WriteCoord, originF[2]+555.0) // z axis
	write_short(g_trail) // sprite
	write_byte(0) // startframe
	write_byte(0) // framerate
	write_byte(4) // life
	write_byte(60) // width
	write_byte(0) // noise
	write_byte(255) // red
	write_byte(215) // green
	write_byte(0) // blue
	write_byte(200) // brightness
	write_byte(0) // speed
	message_end()
}

public kill(const Float:originF[3], attacker){
	static Float:radius, victim = -1;
	radius = 300 / 2.0;
	
	while ((victim = engfunc(EngFunc_FindEntityInSphere, victim, originF, radius)) != 0)
	{
		if (!is_user_alive(victim) || !zp_get_user_zombie(victim))
			continue;
		
		new Float:dam = get_pcvar_float(cvar_holydmg);
		set_msg_block(g_death, BLOCK_SET);
		fakedamage(victim, "", dam, DMG_BLAST);
		set_msg_block(g_death, BLOCK_NOT);
		
		if(get_user_health(victim) <= 0)
		{
			SendDeathMsg(attacker, victim);
			
			if(victim != attacker && !zp_get_user_zombie(attacker))
				UpdateFrags(attacker, 1, 1);
			else
				UpdateFrags(attacker, -1, 1);
		}
	}
}

public holysound(entity){
	if (!pev_valid(entity))
	{
		remove_task(entity);
		return;
	}
	
	emit_sound(entity, CHAN_WEAPON, g_sound, 1.0, ATTN_NORM, 0, PITCH_NORM);
}

SendDeathMsg(attacker, victim) // Sends death message
{
	message_begin(MSG_BROADCAST, g_death)
	write_byte(attacker) // killer
	write_byte(victim) // victim
	write_byte(0) // headshot flag
	write_string("holygrenade") // killer's weapon
	message_end()
}

UpdateFrags(attacker, frags, scoreboard) // Updates attacker frags
{
	// Set attacker frags
	set_pev(attacker, pev_frags, float(pev(attacker, pev_frags) + frags))
		
	// Update scoreboard with attacker and victim info
	if (scoreboard)
	{
		message_begin(MSG_BROADCAST, g_score)
		write_byte(attacker) // id
		write_short(pev(attacker, pev_frags)) // frags
		write_short(get_user_deaths(attacker)) // deaths
		write_short(0) // class?
		write_short(get_user_team(attacker)) // team
		message_end()
	}
}
